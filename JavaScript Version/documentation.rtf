{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf460
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red53\green53\blue53;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
Whack-a-fraudster\
\
The Whack-a-fraudster game is a basic html, dom element based game. Alternatively it could have been as a html canvas game. The libraries used in the game are: jQuery and GSAP (green sock).\
\
	The game has a basic scoring system which records the number of \'93bad guys\'94 the player manages to click as well as the number of \'93customers\'94 the player accidentally clicks. There is also a \'93super bad guy\'94 which scores greatly and only appears once per play of the game.\
\
The scoring system:\
	As mentioned above the game has a scoring system. This system uses a global array to store [\'93bad guy clicks\'94, \'93customer clicks\'94, \'93super bad guy click\'94]. e.g. [12,2,1] would represent 12 bad guys, 2 customers and a super bad guy. The scoring system uses this array to calculate the score on the fly and eventually generate the resulting statistics on the final screen. There is 2 readouts for the scoring on the final screen; text reading a summary of clicks e.g \'93You denied 25 fraudsters, 1 genuine customers and you caught the super bad fraudster\'94 as well as a graphical representation of the same data.\
	\
		The graphical data:\
			The data is organised is a horizontal bar chart with the origin in the centre of the screen. The chart has a width of 80% of the screen to display the data. The 80% is converted into a pixel value and the number of available pixels is divided by the total score to get the pixel value at the screen size to represent the score for each category (bad guy, customer, super bad guy).\
\
\
The game has a launch screen with some instructions and some basic initial setup/configuration.\'a0\
\
The launch screen & loading/resizing:\
	Loading the game sets the height of the body to the height of the window and the spacing of the instruction columns. Re-size triggers both the functions that control this so that the layout is fluid and never requires any scrolling.\
	The launch screen features the title of the game, some basic information about the game and how it is played, the featurespace logo and a start button to start playing the game.\
\
The start/end game button:\
	The start button triggers a lot of function calls to setup the game; interface, scoring system, starting bad guys and customers, ect\'85\
	Once the game is underway the button text and functionality changes to end the game. Pressing the button in this state will trigger showing the final score screen, stop the game and hide/show relevant elements.\
	To accomplish this functionality conditional statement is triggered inside the click listener attached to the button. i.e (the button text is \'93Start Game\'94 do \'97>\'a0\
else stop the game and so do \'97>\
\
In the game the grid interface appears as well as a reset button. The reset button will bring the game all the way back to the starting point and so won\'92t display the score. (this differs from the end game button behaviour).\
\
\
The Grid:\
	The grid is generated by the \'93setGrid\'94 function. The function is also responsible for increasing the size of the grid throughout the game as the levels progress. To accomplish this the function takes a parameter for size. In the starting case the game is a 3x3 grid so the parameter is 3. ( setGrid(3); )\
	The parameter is used in a for loop to generate the correct number of tiles ( for(var i=0;i < size*size; i++)\{\} ) where size is the parameter. In each iteration of the for loop an element is created ( $('.gridContainer').append("<div class='gridBox'></div>") ) and appended to the grid container. The elements are clouded in alternating colours by css odd and even nth of type. The width of the container is set by multiplying the size parameter by 50 (the size of each tile) and the logo is set to the middle tile by getting the middle element of type gridbox/tile and giving it the logo gridLogo class.\
	The grid function also attaches the click event handlers to the gridBox/tile. on clicking a tile a conditional checks if the tile has a class of one of our characters (bad guy, customer, super bad guy). If the tile has one of the classes a function to remove the character in question is called and the update score function is called with character as the parameter and the delayed call to remove the character is canceled (both the delayed call and canceling the delayed call are green sock functionalities) the class for the relevant character is also removed in the listener.\
	Lastly upon calling the setGrid function 2 additional customers and 1 additional bad guy are thrown into the game. (on start 2:1 ratio, this increases throughout the game as the levels progress)\
\
Global variables:\
	There are 6 global variables: score (array), playing (bool), difficulty (int), superBadGuy (int), superBadGuyPassed (bool), level (int).\
	As mentioned above \'91score\'92 is an array to control the scoring. playing is a bool which is true with the game is being played and false when the game is ended or reset. difficulty (default is 2) is the base difficulty which represents 2 seconds and that means each character will be present/clickable for <difficulty number of seconds> when a level is passed 0.25 is taken off from the base difficulty so as the game progresses it becomes harder to click the characters. superBadGuy is set by a function which generates a random number between 1 and 3. This represents the random level on which the superBadGuy will appear. superBadGuyPassed is a bool that is set to true by default to control if the game can progress to the next level. This is used to make sure that the level isn\'92t passed if the superBadGuy hasn\'92t been displayed yet. If the superBadGuy is on the level the player is currently on the variable is set to false until the superBadGuy disappears through clicking or running out of time. level is used to compare the current level to the superBadGuy level.\
\
Annimate Chars:\
	Large images of the characters appear on the screen from the side while the game is being played. This is to make the game feel a bit more immersive and to use some of the empty screen space. This is done in 3 functions that are pretty self explanatory. firstly animating the large chars in which cancels any delayed calls to remove the chars from the screen and shows them (off the screen) and then animates them to their positions. The second function is an animate out function which animates them out and sets a delayed call with the animation time to the 3rd function which hides the elements.\
\
SuperBadGuy:\
	The super bad guy appears once during each game on a random level with a random time delay of up to 8 seconds. Therefore the game must wait on the random level of the super Bad Guy for him to appear and the player to have a chance to catch the super bad guy. To accomplish this several functions are used. The first is used at the start and sets a random level for the super bad guy. The next is \'91checkSuperBadGuy\'92 which is called at the start of the game and every time the score is updated. The function checks if the current level is the super bad guy level. If the level matches the boolean variable for superBadGuyPassed is set to false. This will keep the game on that level until the superBadGuy has passed either through the player clicking or running out of time to click him.}